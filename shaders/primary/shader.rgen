#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_GOOGLE_include_directive : require

// set 0 - scene
// set 1 - background
// set 2 - display

layout(binding = 0, set = 2, rgba32f) uniform writeonly image2D displayImage;
layout(binding = 1, set = 2, rgba32f) uniform image2D accumulationImage;

layout(binding = 0, set = 0) uniform accelerationStructureEXT TLAS;

#include "common.glsl"
#include "reflection_frame.glsl"
#include "random.glsl"
#include "microfacet.glsl"
#include "background.glsl"

struct Camera {
    vec3 origin;
    vec3 lower_left_corner;
    vec3 horizontal;
    vec3 vertical;
    vec3 u, v;
    float lens_radius;
};

layout(push_constant, scalar) uniform cam {
    Camera camera;
    uint numAccumulatedFrames;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

const uint SAMPLES_PER_FRAME = 1;
const uint MAX_BOUNCES = 4;

Ray generateDir(Camera camera, vec4 rand) {
    vec2 sampled_rand = squareToUniformDiskConcentric(rand.xy);
    vec2 rd = camera.lens_radius * sampled_rand;
    vec3 defocusOffset = camera.u * rd.x + camera.v * rd.y;
    
    vec2 randomCenter = vec2(0.5) + 0.5 * randomGaussian(rand.zw);
    vec2 uv = (vec2(gl_LaunchIDEXT.xy) + randomCenter) / vec2(gl_LaunchSizeEXT.xy);
    uv.y -= 1;
    uv.y *= -1;

    Ray ray;
    ray.origin = camera.origin + defocusOffset;
    ray.direction = normalize(camera.lower_left_corner + uv.x * camera.horizontal + uv.y * camera.vertical - defocusOffset - camera.origin);

    return ray;
}

vec3 pathTrace(inout Rng rng, vec3 initialOrigin, vec3 initialDirection) {
    vec3 accumulatedColor = vec3(0.0);

    vec3 origin = initialOrigin;
    vec3 direction = initialDirection;

    vec3 throughput = vec3(1.0);

    for (uint bounceCount = 0; bounceCount < MAX_BOUNCES; bounceCount++) {
        
        traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, 0.0001, direction, 10000.0, 0);

        if (!payload.done) {
            Material material = getMaterial(payload.materialIndex, payload.texcoord);
            
            Frame frame = createFrame(payload.normal);
            vec3 outgoing = worldToFrame(frame, -direction);
            
            vec4 rand1 = vec4(getFloat(rng), getFloat(rng), getFloat(rng), getFloat(rng));
            vec3 lightSample1 = estimateBackgroundDirect(frame, outgoing, material, rand1);
            vec4 rand2 = vec4(getFloat(rng), getFloat(rng), getFloat(rng), getFloat(rng));
            vec3 lightSample2 = estimateBackgroundDirect(frame, outgoing, material, rand2);
            accumulatedColor += (throughput * (lightSample1 + lightSample2) / 2.0);
            
            // set up info for next bounce
            origin = payload.point;
            float pdf;
            float u = getFloat(rng);
            float v = getFloat(rng);
            vec3 incoming = sample_f_r(outgoing, material, pdf, vec2(u, v));
            if (!sameHemisphere(outgoing, incoming)) {
                break;
            }
            direction = frameToWorld(frame, incoming);
            throughput *= f_r(incoming, outgoing, material) * abs(frameCosTheta(incoming)) / pdf;
        } else {
            // no hit, we're done
            if (bounceCount == 0) {
                // if primary ray, add background
                accumulatedColor += throughput * getBackgroundColor(direction);
            }
            break;
        }
    }

    return accumulatedColor;
}

void storeColor(vec3 color) {
    ivec2 imageCoords = ivec2(gl_LaunchIDEXT.xy);
    vec3 previouslyAccumulated;
    if (numAccumulatedFrames == 0) {
        previouslyAccumulated = vec3(0);
    } else {
        previouslyAccumulated = imageLoad(accumulationImage, imageCoords).rgb;
    }
    imageStore(accumulationImage, imageCoords, vec4(previouslyAccumulated + color, 1.0));
    imageStore(displayImage, imageCoords, vec4((previouslyAccumulated + color) / ((numAccumulatedFrames + 1) * SAMPLES_PER_FRAME), 1.0));
}

void main() {
    Rng rng = InitRng((numAccumulatedFrames + 1) * gl_LaunchSizeEXT.x * gl_LaunchIDEXT.x + gl_LaunchIDEXT.y);

    // the result that we write to our buffer
    vec3 color = vec3(0.0);

    for (uint sampleCount = 0; sampleCount < SAMPLES_PER_FRAME; sampleCount++) {
        // set up initial directions for first bounce
        vec4 rand = vec4(getFloat(rng), getFloat(rng), getFloat(rng), getFloat(rng));
        Ray initialRay = generateDir(camera, rand);

        color += pathTrace(rng, initialRay.origin, initialRay.direction);
    }

    storeColor(color);
}
