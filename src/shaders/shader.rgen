// minimal shader for testing
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_GOOGLE_include_directive : require

#include "common.glsl"

layout(binding = 0, set = 0, rgba32f) uniform writeonly image2D displayImage;
layout(binding = 1, set = 0, rgba32f) uniform image2D accumulationImage;
layout(binding = 2, set = 0) uniform accelerationStructureEXT TLAS;

layout(location = 0) rayPayloadEXT Payload payload;
layout(location = 1) rayPayloadEXT bool inShadow;

struct Camera {
    vec3 origin;
    vec3 lower_left_corner;
    vec3 horizontal;
    vec3 vertical;
};

layout(push_constant, scalar) uniform cam {
    Camera camera;
    uint numAccumulatedFrames;
};

vec3 generateDir(Camera camera, vec2 uv) {
    return camera.lower_left_corner + uv.x * camera.horizontal + uv.y * camera.vertical - camera.origin;
}

uint stepRNG(uint rngState) {
    return rngState * 747796405 + 1;
}

float stepAndOutputRNGFloat(inout uint rngState) {
    rngState  = stepRNG(rngState);
    uint word = ((rngState >> ((rngState >> 28) + 4)) ^ rngState) * 277803737;
    word = (word >> 22) ^ word;
    return float(word) / 4294967295.0;
}

const float PI = 3.14159265;

vec3 randomDirection(inout uint rngState) {
    const float theta = 2 * PI * stepAndOutputRNGFloat(rngState);
    const float u = 2.0 * stepAndOutputRNGFloat(rngState) - 1.0;
    const float r = sqrt(1.0 - u * u);
    return vec3(r * cos(theta), r * sin(theta), u);
}

vec2 randomGaussian(inout uint rngState) {
    const float u1 = max(1e-38, stepAndOutputRNGFloat(rngState));
    const float u2 = stepAndOutputRNGFloat(rngState);
    const float r = sqrt(-2.0 * log(u1));
    const float theta = 2 * PI * u2;
    return r * vec2(cos(theta), sin(theta));
}

// should this be a uniform?
const vec3 SUN_DIR = vec3(-0.494118, 0.406275, -0.768628);

void main() {
    uint rngState = (numAccumulatedFrames + 1) * gl_LaunchSizeEXT.x * gl_LaunchIDEXT.x + gl_LaunchIDEXT.y;

    vec3 accumulatedColor = vec3(0.0);

    const uint MAX_BOUNCES = 32;
    const uint SAMPLES_PER_FRAME = 4;
    for (uint sampleCount = 0; sampleCount < SAMPLES_PER_FRAME; sampleCount++) {
        vec3 bouncedColor = vec3(1.0);

        vec2 randomCenter = vec2(0.5) + 0.25 * randomGaussian(rngState);
        vec2 uv = (vec2(gl_LaunchIDEXT.xy) + randomCenter) / vec2(gl_LaunchSizeEXT.xy);
        uv.y -= 1;
        uv.y *= -1;

        vec3 direction = normalize(generateDir(camera, uv));
        traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, camera.origin, 0.0001, direction, 10000.0, 0);
        bouncedColor *= payload.attenuation;
        if (payload.done) {
            accumulatedColor += bouncedColor;
            continue;
        }
        inShadow = true;
        if (dot(payload.normal, SUN_DIR) > 0.0) { 
            uint flags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
            traceRayEXT(TLAS, flags, 0xFF, 0, 0, 1, payload.point, 0.001, SUN_DIR, 10000.0, 1);
        }
        if (!inShadow) {
            accumulatedColor += 0.5 * payload.attenuation;
        }

        for (uint bounceCount = 1; bounceCount < MAX_BOUNCES; bounceCount++) {
            if (bounceCount == MAX_BOUNCES) {
                break;
            }
            vec3 origin = payload.point;
            vec3 normal = faceforward(payload.normal, direction, payload.normal);
            direction = normalize(normal + randomDirection(rngState));
            traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, 0.0001, direction, 10000.0, 0);

            bouncedColor *= payload.attenuation;

            if (payload.done) {
                accumulatedColor += bouncedColor;
                break;
            }
        }
    }
    ivec2 imageCoords = ivec2(gl_LaunchIDEXT.xy);
    vec3 previouslyAccumulated;
    if (numAccumulatedFrames == 0) {
        previouslyAccumulated = vec3(0);
    } else {
        previouslyAccumulated = imageLoad(accumulationImage, imageCoords).rgb;
    }
    imageStore(accumulationImage, imageCoords, vec4(previouslyAccumulated + accumulatedColor, 1.0));
    imageStore(displayImage, imageCoords, vec4((previouslyAccumulated + accumulatedColor) / ((numAccumulatedFrames + 1) * SAMPLES_PER_FRAME), 1.0));
}
